{
    "sourceFile": "src/category/infra/db/sequelize/__tests__/category-sequelize.repository.int.spec.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1694956188567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1694956197103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,5 +71,12 @@\n     const entityFound = await repository.findById(entity.category_id);\n     expect(entity.toJSON()).toStrictEqual(entityFound.toJSON());\n   });\n \n+  it(\"should throw error on delete when a entity not found\", async () => {\n+    const categoryId = new Uuid();\n+    await expect(repository.delete(categoryId)).rejects.toThrow(\n+      new NotFoundError(categoryId.id, Category)\n+    );\n+  });\n+\n })\n\\ No newline at end of file\n"
                },
                {
                    "date": 1694956205663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,5 +78,13 @@\n       new NotFoundError(categoryId.id, Category)\n     );\n   });\n \n+  it(\"should delete a entity\", async () => {\n+    const entity = new Category({ name: \"Movie\" });\n+    await repository.insert(entity);\n+\n+    await repository.delete(entity.category_id);\n+    await expect(repository.findById(entity.category_id)).resolves.toBeNull();\n+  });\n+\n })\n\\ No newline at end of file\n"
                },
                {
                    "date": 1694956238663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,5 +86,244 @@\n     await repository.delete(entity.category_id);\n     await expect(repository.findById(entity.category_id)).resolves.toBeNull();\n   });\n \n+  describe(\"search method tests\", () => {\n+    it(\"should only apply paginate when other params are null\", async () => {\n+      const created_at = new Date();\n+      const categories = Category.fake()\n+        .theCategories(16)\n+        .withName(\"Movie\")\n+        .withDescription(null)\n+        .withCreatedAt(created_at)\n+        .build();\n+      await repository.bulkInsert(categories);\n+      const spyToEntity = jest.spyOn(CategoryModelMapper, \"toEntity\");\n+\n+      const searchOutput = await repository.search(new CategorySearchParams());\n+      expect(searchOutput).toBeInstanceOf(CategorySearchResult);\n+      expect(spyToEntity).toHaveBeenCalledTimes(15);\n+      expect(searchOutput.toJSON()).toMatchObject({\n+        total: 16,\n+        current_page: 1,\n+        last_page: 2,\n+        per_page: 15,\n+      });\n+      searchOutput.items.forEach((item) => {\n+        expect(item).toBeInstanceOf(Category);\n+        expect(item.category_id).toBeDefined();\n+      });\n+      const items = searchOutput.items.map((item) => item.toJSON());\n+      expect(items).toMatchObject(\n+        new Array(15).fill({\n+          name: \"Movie\",\n+          description: null,\n+          is_active: true,\n+          created_at: created_at,\n+        })\n+      );\n+    });\n+\n+    it(\"should order by created_at DESC when search params are null\", async () => {\n+      const created_at = new Date();\n+      const categories = Category.fake()\n+        .theCategories(16)\n+        .withName((index) => `Movie ${index}`)\n+        .withDescription(null)\n+        .withCreatedAt((index) => new Date(created_at.getTime() + index))\n+        .build();\n+      const searchOutput = await repository.search(new CategorySearchParams());\n+      const items = searchOutput.items;\n+      [...items].reverse().forEach((item, index) => {\n+        expect(`Movie ${index}`).toBe(`${categories[index + 1].name}`);\n+      });\n+    });\n+\n+    it(\"should apply paginate and filter\", async () => {\n+      const categories = [\n+        Category.fake()\n+          .aCategory()\n+          .withName(\"test\")\n+          .withCreatedAt(new Date(new Date().getTime() + 5000))\n+          .build(),\n+        Category.fake()\n+          .aCategory()\n+          .withName(\"a\")\n+          .withCreatedAt(new Date(new Date().getTime() + 4000))\n+          .build(),\n+        Category.fake()\n+          .aCategory()\n+          .withName(\"TEST\")\n+          .withCreatedAt(new Date(new Date().getTime() + 3000))\n+          .build(),\n+        Category.fake()\n+          .aCategory()\n+          .withName(\"TeSt\")\n+          .withCreatedAt(new Date(new Date().getTime() + 1000))\n+          .build(),\n+      ];\n+\n+      await repository.bulkInsert(categories);\n+\n+      let searchOutput = await repository.search(\n+        new CategorySearchParams({\n+          page: 1,\n+          per_page: 2,\n+          filter: \"TEST\",\n+        })\n+      );\n+      expect(searchOutput.toJSON(true)).toMatchObject(\n+        new CategorySearchResult({\n+          items: [categories[0], categories[2]],\n+          total: 3,\n+          current_page: 1,\n+          per_page: 2,\n+        }).toJSON(true)\n+      );\n+\n+      searchOutput = await repository.search(\n+        new CategorySearchParams({\n+          page: 2,\n+          per_page: 2,\n+          filter: \"TEST\",\n+        })\n+      );\n+      expect(searchOutput.toJSON(true)).toMatchObject(\n+        new CategorySearchResult({\n+          items: [categories[3]],\n+          total: 3,\n+          current_page: 2,\n+          per_page: 2,\n+        }).toJSON(true)\n+      );\n+    });\n+\n+    it(\"should apply paginate and sort\", async () => {\n+      expect(repository.sortableFields).toStrictEqual([\"name\", \"created_at\"]);\n+\n+      const categories = [\n+        Category.fake().aCategory().withName(\"b\").build(),\n+        Category.fake().aCategory().withName(\"a\").build(),\n+        Category.fake().aCategory().withName(\"d\").build(),\n+        Category.fake().aCategory().withName(\"e\").build(),\n+        Category.fake().aCategory().withName(\"c\").build(),\n+      ];\n+      await repository.bulkInsert(categories);\n+\n+      const arrange = [\n+        {\n+          params: new CategorySearchParams({\n+            page: 1,\n+            per_page: 2,\n+            sort: \"name\",\n+          }),\n+          result: new CategorySearchResult({\n+            items: [categories[1], categories[0]],\n+            total: 5,\n+            current_page: 1,\n+            per_page: 2,\n+          }),\n+        },\n+        {\n+          params: new CategorySearchParams({\n+            page: 2,\n+            per_page: 2,\n+            sort: \"name\",\n+          }),\n+          result: new CategorySearchResult({\n+            items: [categories[4], categories[2]],\n+            total: 5,\n+            current_page: 2,\n+            per_page: 2,\n+          }),\n+        },\n+        {\n+          params: new CategorySearchParams({\n+            page: 1,\n+            per_page: 2,\n+            sort: \"name\",\n+            sort_dir: \"desc\",\n+          }),\n+          result: new CategorySearchResult({\n+            items: [categories[3], categories[2]],\n+            total: 5,\n+            current_page: 1,\n+            per_page: 2,\n+          }),\n+        },\n+        {\n+          params: new CategorySearchParams({\n+            page: 2,\n+            per_page: 2,\n+            sort: \"name\",\n+            sort_dir: \"desc\",\n+          }),\n+          result: new CategorySearchResult({\n+            items: [categories[4], categories[0]],\n+            total: 5,\n+            current_page: 2,\n+            per_page: 2,\n+          }),\n+        },\n+      ];\n+\n+      for (const i of arrange) {\n+        const result = await repository.search(i.params);\n+        expect(result.toJSON(true)).toMatchObject(i.result.toJSON(true));\n+      }\n+    });\n+\n+    describe(\"should search using filter, sort and paginate\", () => {\n+      const categories = [\n+        Category.fake().aCategory().withName(\"test\").build(),\n+        Category.fake().aCategory().withName(\"a\").build(),\n+        Category.fake().aCategory().withName(\"TEST\").build(),\n+        Category.fake().aCategory().withName(\"e\").build(),\n+        Category.fake().aCategory().withName(\"TeSt\").build(),\n+      ];\n+\n+      const arrange = [\n+        {\n+          search_params: new CategorySearchParams({\n+            page: 1,\n+            per_page: 2,\n+            sort: \"name\",\n+            filter: \"TEST\",\n+          }),\n+          search_result: new CategorySearchResult({\n+            items: [categories[2], categories[4]],\n+            total: 3,\n+            current_page: 1,\n+            per_page: 2,\n+          }),\n+        },\n+        {\n+          search_params: new CategorySearchParams({\n+            page: 2,\n+            per_page: 2,\n+            sort: \"name\",\n+            filter: \"TEST\",\n+          }),\n+          search_result: new CategorySearchResult({\n+            items: [categories[0]],\n+            total: 3,\n+            current_page: 2,\n+            per_page: 2,\n+          }),\n+        },\n+      ];\n+\n+      beforeEach(async () => {\n+        await repository.bulkInsert(categories);\n+      });\n+\n+      test.each(arrange)(\n+        \"when value is $search_params\",\n+        async ({ search_params, search_result }) => {\n+          const result = await repository.search(search_params);\n+          expect(result.toJSON(true)).toMatchObject(search_result.toJSON(true));\n+        }\n+      );\n+    });\n+  });\n+\n })\n\\ No newline at end of file\n"
                },
                {
                    "date": 1694956272236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,10 @@\n import { CategorySequelizeRepository } from \"../category-sequelize.repository\"\n import { Category } from \"../../../../domain/category.entity\"\n import { Uuid } from \"../../../../../shared/domain/value-objects/uuid.vo\"\n import { NotFoundError } from \"../../../../../shared/domain/errors/not-found.error\"\n+import { CategoryModelMapper } from \"../category-mapper\"\n+import { CategorySearchParams, CategorySearchResult } from \"../../../../domain/category.repository\"\n \n describe(\"CategorySequelizeRepository integration test\", () => {\n   let sequelize\n   let repository: CategorySequelizeRepository\n"
                },
                {
                    "date": 1694956292436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n       const spyToEntity = jest.spyOn(CategoryModelMapper, \"toEntity\");\n \n       const searchOutput = await repository.search(new CategorySearchParams());\n       expect(searchOutput).toBeInstanceOf(CategorySearchResult);\n-      expect(spyToEntity).toHaveBeenCalledTimes(15);\n+      // expect(spyToEntity).toHaveBeenCalledTimes(15);\n       expect(searchOutput.toJSON()).toMatchObject({\n         total: 16,\n         current_page: 1,\n         last_page: 2,\n"
                },
                {
                    "date": 1694968735880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n       const spyToEntity = jest.spyOn(CategoryModelMapper, \"toEntity\");\n \n       const searchOutput = await repository.search(new CategorySearchParams());\n       expect(searchOutput).toBeInstanceOf(CategorySearchResult);\n-      // expect(spyToEntity).toHaveBeenCalledTimes(15);\n+      expect(spyToEntity).toHaveBeenCalledTimes(15);\n       expect(searchOutput.toJSON()).toMatchObject({\n         total: 16,\n         current_page: 1,\n         last_page: 2,\n"
                },
                {
                    "date": 1694998127819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,20 +5,14 @@\n import { Uuid } from \"../../../../../shared/domain/value-objects/uuid.vo\"\n import { NotFoundError } from \"../../../../../shared/domain/errors/not-found.error\"\n import { CategoryModelMapper } from \"../category-mapper\"\n import { CategorySearchParams, CategorySearchResult } from \"../../../../domain/category.repository\"\n+import { setupSequelize } from \"../../../../../shared/infra/testing/herpers\"\n \n describe(\"CategorySequelizeRepository integration test\", () => {\n-  let sequelize\n   let repository: CategorySequelizeRepository\n+  setupSequelize({ models: [CategoryModel] });\n   beforeEach(async () => {\n-    sequelize = new Sequelize({\n-      dialect: \"sqlite\",\n-      storage: \":memory:\",\n-      models: [CategoryModel],\n-      logging: false\n-    })\n-    await sequelize.sync({ force: true })\n     repository = new CategorySequelizeRepository(CategoryModel)\n   })\n \n   it(\"should inserts a new entity\", async () => {\n"
                }
            ],
            "date": 1694956188567,
            "name": "Commit-0",
            "content": "import { Sequelize } from \"sequelize-typescript\"\nimport { CategoryModel } from \"../category.model\"\nimport { CategorySequelizeRepository } from \"../category-sequelize.repository\"\nimport { Category } from \"../../../../domain/category.entity\"\nimport { Uuid } from \"../../../../../shared/domain/value-objects/uuid.vo\"\nimport { NotFoundError } from \"../../../../../shared/domain/errors/not-found.error\"\n\ndescribe(\"CategorySequelizeRepository integration test\", () => {\n  let sequelize\n  let repository: CategorySequelizeRepository\n  beforeEach(async () => {\n    sequelize = new Sequelize({\n      dialect: \"sqlite\",\n      storage: \":memory:\",\n      models: [CategoryModel],\n      logging: false\n    })\n    await sequelize.sync({ force: true })\n    repository = new CategorySequelizeRepository(CategoryModel)\n  })\n\n  it(\"should inserts a new entity\", async () => {\n    let category = Category.fake().aCategory().build();\n    await repository.insert(category);\n    let entity = await repository.findById(category.category_id);\n    expect(entity.toJSON()).toStrictEqual(category.toJSON());\n  });\n\n  it(\"should finds a entity by id\", async () => {\n    let entityFound = await repository.findById(new Uuid());\n    expect(entityFound).toBeNull();\n\n    const entity = Category.fake().aCategory().build();\n    await repository.insert(entity);\n    entityFound = await repository.findById(entity.category_id);\n    expect(entity.toJSON()).toStrictEqual(entityFound.toJSON());\n  });\n\n  it(\"should finds a entity by id\", async () => {\n    let entityFound = await repository.findById(new Uuid());\n    expect(entityFound).toBeNull();\n\n    const entity = Category.fake().aCategory().build();\n    await repository.insert(entity);\n    entityFound = await repository.findById(entity.category_id);\n    expect(entity.toJSON()).toStrictEqual(entityFound.toJSON());\n  });\n\n  it(\"should return all categories\", async () => {\n    const entity = Category.fake().aCategory().build();\n    await repository.insert(entity);\n    const entities = await repository.findAll();\n    expect(entities).toHaveLength(1);\n    expect(JSON.stringify(entities)).toBe(JSON.stringify([entity]));\n  });\n\n  it(\"should throw error on update when a entity not found\", async () => {\n    const entity = Category.fake().aCategory().build();\n    await expect(repository.update(entity)).rejects.toThrow(\n      new NotFoundError(entity.category_id.id, Category)\n    );\n  });\n\n  it(\"should update a entity\", async () => {\n    const entity = Category.fake().aCategory().build();\n    await repository.insert(entity);\n\n    entity.changeName(\"Movie updated\");\n    await repository.update(entity);\n\n    const entityFound = await repository.findById(entity.category_id);\n    expect(entity.toJSON()).toStrictEqual(entityFound.toJSON());\n  });\n\n})"
        }
    ]
}