{
    "sourceFile": "src/category/application/use-cases/__tests__/integration/update-category.usecase.int.spec.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1695248123892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1695248123892,
            "name": "Commit-0",
            "content": "\nimport { NotFoundError } from \"../../../../../shared/domain/errors/not-found.error\";\nimport { Uuid } from \"../../../../../shared/domain/value-objects/uuid.vo\";\nimport { setupSequelize } from \"../../../../../shared/infra/testing/herpers\";\nimport { Category } from \"../../../../domain/category.entity\";\nimport { CategorySequelizeRepository } from \"../../../../infra/db/sequelize/category-sequelize.repository\";\nimport { CategoryModel } from \"../../../../infra/db/sequelize/category.model\";\n\nimport { UpdateCategoryUseCase } from \"../../update-category/update-category.usecase\";\n\ndescribe('UpdateCategoryUseCase Integration Tests', () => {\n\n  let useCase: UpdateCategoryUseCase;\n  let repository: CategorySequelizeRepository;\n\n  setupSequelize({ models: [CategoryModel] });\n\n  beforeEach(() => {\n    repository = new CategorySequelizeRepository(CategoryModel);\n    useCase = new UpdateCategoryUseCase(repository);\n  });\n\n  it('should throws error when entity not found', async () => {\n    const uuid = new Uuid()\n    await expect(() =>\n      useCase.execute({ id: uuid.id, name: 'fake' }),\n    ).rejects.toThrow(new NotFoundError(uuid.id, Category));\n  })\n\n  it('should update a category', async () => {\n    const entity = Category.fake().aCategory().build();\n    repository.insert(entity);\n\n    let output = await useCase.execute({\n      id: entity.category_id.id,\n      name: 'test',\n    });\n    expect(output).toStrictEqual({\n      id: entity.category_id.id,\n      name: 'test',\n      description: entity.description,\n      is_active: true,\n      created_at: entity.created_at,\n    });\n\n    type Arrange = {\n      input: {\n        id: string;\n        name: string;\n        description?: null | string;\n        is_active?: boolean;\n      };\n      expected: {\n        id: string;\n        name: string;\n        description: null | string;\n        is_active: boolean;\n        created_at: Date;\n      };\n    };\n\n    const arrange: Arrange[] = [\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n          is_active: true,\n          created_at: entity.created_at,\n        },\n      },\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n          is_active: true,\n          created_at: entity.created_at,\n        },\n      },\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n          is_active: false,\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n          is_active: false,\n          created_at: entity.created_at,\n        },\n      },\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n          is_active: false,\n          created_at: entity.created_at,\n        },\n      },\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n          is_active: true,\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: 'some description',\n          is_active: true,\n          created_at: entity.created_at,\n        },\n      },\n      {\n        input: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: null,\n          is_active: false,\n        },\n        expected: {\n          id: entity.category_id.id,\n          name: 'test',\n          description: null,\n          is_active: false,\n          created_at: entity.created_at,\n        },\n      },\n    ];\n\n    for (const i of arrange) {\n      output = await useCase.execute({\n        id: i.input.id,\n        ...(i.input.name && { name: i.input.name }),\n        ...('description' in i.input && { description: i.input.description }),\n        ...('is_active' in i.input && { is_active: i.input.is_active }),\n      });\n      const entityUpdated = await repository.findById(new Uuid(i.input.id));\n      expect(output).toStrictEqual({\n        id: entity.category_id.id,\n        name: i.expected.name,\n        description: i.expected.description,\n        is_active: i.expected.is_active,\n        created_at: entityUpdated.created_at,\n      });\n      expect(entityUpdated.toJSON()).toStrictEqual({\n        category_id: entity.category_id.id,\n        name: i.expected.name,\n        description: i.expected.description,\n        is_active: i.expected.is_active,\n        created_at: entityUpdated.created_at,\n      });\n    }\n  })\n})\n"
        }
    ]
}